% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/multi_omics.R
\name{multi_omic_clustering}
\alias{multi_omic_clustering}
\title{Multi-omic clustering via multi-view clustering or integration}
\usage{
multi_omic_clustering(
  dat_list,
  meta_data = NULL,
  multi_omic_methods = "ANF",
  n_clusters = 2,
  distance_metric = "euclidean",
  correlation_method = "spearman",
  standardize_data = FALSE,
  non_negativity_transform = rep_len("none", length(dat_list)),
  view_distributions = rep_len("gaussian", length(dat_list)),
  icp_lambda = rep(0.03, length(dat_list)),
  icp_burnin = 100,
  icp_draw = 200,
  icp_maxiter = 20,
  icp_sdev = 0.05,
  icp_eps = 1e-04,
  icb_burnin = 1000,
  icb_draw = 1200,
  icb_sdev = 0.5,
  icb_thin = 1,
  nmf_maxiter = 200,
  nmf_st.count = 20,
  nmf_n.ini = 30,
  nmf_ini.nndsvd = TRUE,
  nmf_scaling = "F-ratio",
  mofa_convergence_mode = "medium",
  mofa_maxiter = 1000,
  mofa_environment = NULL,
  mofa_lib_path = NULL,
  anf_neighbors = 20,
  kernels = rep_len("linear", length(dat_list)),
  kernels_center = TRUE,
  kernels_normalize = TRUE,
  kernels_scale_norm = FALSE,
  kernel_gammas = rep_len(0.5, length(dat_list)),
  pathway_networks = NULL,
  pathway_node_betweenness_endpoints = TRUE,
  pathway_first_shortest_path = FALSE,
  pamogk_restart = 0.7,
  pamogk_seeds = "discrete",
  pamogk_seed_under_threshold = qnorm(0.025),
  pamogk_seed_over_threshold = qnorm(0.975),
  kkmeans_algorithm = "qr_decomposition",
  kkmeans_refine = TRUE,
  kkmeans_maxiter = 100,
  kkmeans_n_init = 100,
  kkmeans_tol = 1e-08,
  mkkm_mr_lambda = 1,
  mkkm_mr_tolerance = 1e-08,
  mkkm_mr_mosek = FALSE,
  ecmc_a = 1,
  ecmc_b = 1,
  ecmc_eps = 1e-06,
  ecmc_maxiter = 100,
  ecmc_mkkm_mr = TRUE,
  data_is_kernels = FALSE,
  zero_var_removal = TRUE,
  mvc_threads = 1,
  gene_id_list = NULL,
  preprocess_data = TRUE,
  ...
)
}
\arguments{
\item{dat_list}{List of input \code{data.frame}s for input.}

\item{meta_data}{A single \code{data.frame} or a list that includes meta data for 
each view. If a list is provided, at the moment only the first element is 
used (by appending to clustering output).}

\item{multi_omic_methods}{Vector of algorithm names to be applied. See details.}

\item{n_clusters}{Integer vector of number of clusters to output.}

\item{distance_metric}{Distance metric for clustering factorized data 
(only for MOFA).}

\item{correlation_method}{Correlation method for \code{distance_metric}, 
if applicable.}

\item{standardize_data}{If set, standardizes data before clustering.}

\item{non_negativity_transform}{Vector of transformation names for IntNMF. 
See details below.}

\item{view_distributions}{A vector specifying the distribution to use for each view. 
Used by iCluster+, iClusterBayes and MOFA2. 
Options are "gaussian", "bernoulli" and "poisson".}

\item{icp_lambda}{iCluster+ L1 penalty for each view. 
See \code{\link[iClusterPlus]{iClusterPlus}}.}

\item{icp_burnin}{iCluster+ number of MCMC burn in samples for approximating 
joint distribution of latent variables. 
See \code{\link[iClusterPlus]{iClusterPlus}}.}

\item{icp_draw}{iCluster+ number of MCMC samples to draw after burn in for 
approximating joint distribution of latent variables.  
See \code{\link[iClusterPlus]{iClusterPlus}}.}

\item{icp_maxiter}{iCluster+ maximum number of Newton-Rhapson (EM) iterations. 
See \code{\link[iClusterPlus]{iClusterPlus}}.
\code{\link[iClusterPlus]{iClusterBayes}}.}

\item{icp_sdev}{iCluster+ MCMC random walk standard deviation. 
See \code{\link[iClusterPlus]{iClusterPlus}}.}

\item{icp_eps}{iCluster+ algorithm convergence threshold. 
See \code{\link[iClusterPlus]{iClusterPlus}}.}

\item{icb_burnin}{iClusteBayes number of samples for MCMC burn in. 
See \code{\link[iClusterPlus]{iClusterBayes}}.}

\item{icb_draw}{iClusteBayes number of MCMC samples to draw after burn in. 
See \code{\link[iClusterPlus]{iClusterBayes}}.}

\item{icb_sdev}{iClusteBayes MCMC random walk standard deviation. 
See \code{\link[iClusterPlus]{iClusterBayes}}.}

\item{icb_thin}{iClusteBayes MCMC thinning, only one sample in every icb_thin 
samples will be used. 
See \code{\link[iClusterPlus]{iClusterBayes}}.}

\item{nmf_maxiter}{Maxiter for IntNMF. See 
\code{\link[IntNMF]{nmf.mnnals}}.}

\item{nmf_st.count}{Count stability for IntNMF. 
See \code{\link[IntNMF]{nmf.mnnals}}.}

\item{nmf_n.ini}{Number of initializations for IntNMF. 
See \code{\link[IntNMF]{nmf.mnnals}}.}

\item{nmf_ini.nndsvd}{If set, IntNMF uses NNDSVD for initialization. 
See \code{\link[IntNMF]{nmf.mnnals}}.}

\item{nmf_scaling}{Omic weights that are used for scaling. Defaults to the 
Frobenius norm ratio similarly to Chalise et al. 2017.}

\item{mofa_convergence_mode}{MOFA convergence threshold. 
See \code{\link[MOFA2]{get_default_training_options}}.}

\item{mofa_maxiter}{MOFA maximum iterations. 
See \code{\link[MOFA2]{get_default_training_options}}.}

\item{mofa_environment}{If set, uses the specified Python environment 
(with mofapy). Defaults to basilisk.}

\item{mofa_lib_path}{Path to libpython. May be required if using non-default 
\code{mofa_environment}.}

\item{anf_neighbors}{Number of neighbours to use in knn-graph.}

\item{kernels}{Character vector of kernel names to use for different views. 
See details.}

\item{kernels_center}{Logical vector specifying which kernels should be 
centered. Repeated for each view if length 1.}

\item{kernels_normalize}{Logical vector specifying which kernels should be 
normalized Repeated for each view if length 1.}

\item{kernels_scale_norm}{Logical vector specifying which kernels should be 
scaled to unit F-norm. Repeated for each view if length 1.}

\item{kernel_gammas}{Numeric vector specifying gamma for the gaussian kernel.}

\item{pathway_networks}{List of \code{igraph} objects containing pathway 
networks. Required for pathway kernels.}

\item{pathway_node_betweenness_endpoints}{whether to include shortest path 
endpoints in betweenness. Including it results in more non-zero weights 
in BWK and PAMOGK.}

\item{pamogk_restart}{Restart probability for PAMOGK RWR.}

\item{pamogk_seeds}{Seed selection strategy for PAMOGK RWR, one of: 
"discrete", "continuous", "threshold". See details below.}

\item{pamogk_seed_under_threshold}{z-score threshold for under-expressed.}

\item{pamogk_seed_over_threshold}{z-score threshold for over-expressed.}

\item{kkmeans_algorithm}{See \code{\link{kernel_kmeans}}.}

\item{kkmeans_refine}{See \code{\link{kernel_kmeans}}.}

\item{kkmeans_maxiter}{See \code{\link{kernel_kmeans}}.}

\item{kkmeans_n_init}{See \code{\link{kernel_kmeans}}.}

\item{kkmeans_tol}{See \code{\link{kernel_kmeans}}.}

\item{mkkm_mr_lambda}{Regularization parameter for \code{\link{mkkm_mr}}.}

\item{mkkm_mr_tolerance}{Convergence threshold for \code{\link{mkkm_mr}}.}

\item{mkkm_mr_mosek}{If set, uses \code{Rmosek} for convex optimization 
instead of \code{CVXR} for \code{\link{mkkm_mr}}.}

\item{ecmc_a}{Regularization parameter for \code{\link{ECMC}}.}

\item{ecmc_b}{Regularization parameter for \code{\link{ECMC}}.}

\item{ecmc_eps}{Convergence threshold for \code{\link{ECMC}}.}

\item{ecmc_maxiter}{Maximum number of iterations for \code{\link{ECMC}}.}

\item{ecmc_mkkm_mr}{If set, uses \code{\link{mkkm_mr}} on consensus kernels 
obtained from \code{\link{ECMC}}. Otherwise uses the average kernel and 
  kernel k-means.}

\item{data_is_kernels}{If set, input data is assumed to be kernel matrices. 
Otherwise kernels are computed based on input data and the 
\code{kernels} parameter.}

\item{zero_var_removal}{If set, removes all zero variance features 
from the data. It is called fold-wise, because this is assumed to be run 
inside CV.}

\item{mvc_threads}{Number of threads to use for supported operations.}

\item{gene_id_list}{List of gene/feature names for each view. If set, matches 
pipeline standardized feature names ("dim1", "dim2", ...) to names on the list. 
Required for pathway kernels.}

\item{preprocess_data}{If the input data has already been processed by the 
\code{\link{COPS}}-pipeline, this should be disabled.}

\item{...}{Arguments are passed to \code{\link{clustering_analysis}} when using MOFA.}
}
\value{
\code{data.frame} of clustering results
}
\description{
Multi-omic clustering via multi-view clustering or integration
}
\details{
Supported methods:
\itemize{
  \item "ANF" - Affinity Network Fusion \code{\link[ANF]{ANF}}
  \item "iClusterPlus" or "iCluster+" - \code{\link[iClusterPlus]{iClusterPlus}}. Supports only up to 4 views. 
  \item "iClusterBayes" -  code{\link[iClusterPlus]{iClusterBayes}}. Supports only up to 6 views
  \item "IntNMF" - Integrative Non-negative Matrix Factorization 
    \code{\link[IntNMF]{nmf.mnnals}}.
  \item "average_kernel" - kernel k-means with average kernel. 
  \item "mkkm_mr" - Multiple Kernel K-Means with Matrix-induced Regularization 
    \code{\link{mkkm_mr}}.
  \item "ECMC" - Enhanced Consensus Multi-view Clustering \code{\link{ECMC}}.
  \item "MOFA2" - Multi-Omics Factor Analysis. 
    See \code{vignette("getting_started_R", "MOFA2")}. 
    Resulting factorization is clustered with single-view algorithms by using 
    \code{\link{clustering_analysis}}.
}

Supported kernels: 
\itemize{
  \item "linear" - Linear kernel based on standard dot product. 
  \item "gaussian", "rbf" - Gaussian kernel, a.k.a. radial basis function.
  \item "jaccard" - Kernel based on Jaccard index. Used for binary features. 
  \item "tanimoto" - For now, this is identical to "jaccard".
  \item "BWK" - Betweenness Weighted Kernel. Uses pathway networks to compute 
    betweenness centrality which is used to weight features in a linear 
    pathway kernels. 
  \item "PAMOGK" - PAthway Multi-Omics Graph Kernel (Tepeli et al. 2021). 
    Uses z-scores, RWR and shortest paths in pathway networks to create 
    pathway kernels. 
  \item "PIK" - Pathway Induced Kernel (Manica et al. 2019). Uses pathway 
    network adjacency matrices (specifically normalized Laplacians) to define 
    pathway kernels. 
}
Please note that for pathway kernels, the input data must always be mapped to 
genes and that the names must match with the gene names in the pathways. 
The default set of pathways is KEGG molecular pathways with gene symbols. 

PAMOGK RWR seed weight options:
\itemize{
  \item "discrete" - 1 if |z| > t, 0 otherwise. 
  \item "continuous" - z
  \item "threshold" - z if |z| > t, 0 otherwise
}
Regardless of the option, the seeds are divided into two sets based on the 
sign of the z-score. Each set has a separate smoothing step and the end 
result is two different kernels per pathway per omic. This impacts the 
RWR label smoothing by changing the initial distribution. 

NMF non-negativity transform may be necessary if non-negativity was not 
considered while pre-processing the data. There are a few convenience 
functions included to transform the data as needed: 
\itemize{
  \item "logistic" - \code{1/(1 + exp(-x))}, maps input from (-Inf,Inf) to [0,1]. 
    Used for e.g. microarray data or methylation M-values. 
  \item "rank" - ranks values and divides by length, maps input from 
    (-Inf,Inf) to [0,1].
  \item "offset2" - adds 2 to input. Useful for e.g. copy number alterations 
    (assuming no alterations lower than -2). 
}
}
