---
title: "Introduction to ThETA"
author: "Mario Failli, Jussi Pananen and Vittorio Fortino"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Introduction to ThETA}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

<style type="text/css">

body{ /* Normal  */
      font-size: 12px;
  }
td {  /* Table  */
  font-size: 10px;
}
h1.title {
  font-size: 30px;
  color: DarkRed;
}
h1 { /* Header 1 */
  font-size: 24px;
  color: DarkBlue;
}
h2 { /* Header 2 */
    font-size: 20px;
  color: DarkBlue;
}
h3 { /* Header 3 */
  font-size: 15px;
  font-family: "Times New Roman", Times, serif;
  color: DarkBlue;
}
code.r{ /* Code block */
    font-size: 10px;
}
pre { /* Code block - determines code spacing between lines */
    font-size: 10px;
}
</style>

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Compile transcriptome-driven efficacy estimates of target(gene)-disease associations

The R package COPS provides a suite of feature reduction techniques and clustering algorithms for disease subtype discovery from omics data.

**Current functions provided by COPS**

* Dimensional reduction: PCA, S-TNE and UMAP. 
* Knowledge-driven feature extraction: pathway and network analysis.
* Single-omics clustering algorithms: 
* Multi-omics clustering algorithms: 
* Benchmarking functions.

## 1. How to ..

In order to compile tissue-specific efficacy estimates of drug-target disease associations we need to:

Example starting from processed data matrix 'pso_comb' and batch label vector 'batch'

```{r, load_theta, cache.lazy = TRUE, echo = TRUE, message = FALSE}

#dat_list <- list(pso_comb)

method_evaluations <- dimred_clusteval_pipeline(list(ad_ge_micro_zscore), batch_label = ad_studies, parallel = TRUE,
                                                CVFOLDS = 5, dimred_methods = c("pca", "umap"),
                                                cluster_methods = c("hierarchical", "kmeans"),
                                                metric = "euclidean, "
                                                n_clusters = 2:4)
#' scores <- clusteval_scoring(method_evaluations)
#'
#' # List all scores
#' scores$all
#'
#' # Generate embedding and clustering based on best setting
#' best <- dimred_cluster(dat_list, scores$best)
#'
#' # Associations in best embedding
#' swamp::confounding(data.frame(best$embedding, factor(best$clustering), factor(batch)))
#' class_associations(t(best$embedding), cbind(clust = best$clustering, batch = batch))
#'
#' # Associations in original data
#' class_associations(dat_list[[scores$best$data_set]],
#'                    cbind(clust = best$clustering, batch = batch))
#' #swamp::confounding(data.frame(t(dat_list[[scores$best$data_set]]),
#' #                              factor(best$clustering), factor(batch)))
#'
#' ## Example for analyzing embeddings generated by other methods
#' write.csv(t(pso_comb), file = "pso_combined_gexpr.csv")
#' write.csv(batch, file = "pso_batches.csv")
#' # Run variational autoencoder in python --> load output back to R
#' vae_embeddings <- read.csv("pso_vae_embeddings.csv", header = FALSE, comment.char = "#")
#' vae_params <- read.csv("pso_vae_params.csv", header = FALSE, comment.char = "#")
#' # Manual handling of headers
#' f = file("pso_vae_embeddings.csv", 'r')
#' colnames(vae_embeddings) <- gsub("[ #]", "", strsplit(readLines(f, n=1), ",")[[1]])
#' close(f)
#' f = file("pso_vae_params.csv", 'r')
#' colnames(vae_params) <- gsub("[ #]", "", strsplit(readLines(f, n=1), ",")[[1]])
#' close(f)
#' # TODO: convert embedding analysis into general functions or modify pipeline to acommodate
#'
#' }
```


The output is a *data.frame* object containing the TSE score for all genes-tissue pairs.

```{r, cache = TRUE, echo = FALSE, message = FALSE}
knitr::kable(T2DM_Tscores[1:5,], format = 'html') %>%
  kableExtra::kable_styling(bootstrap_options = "striped", full_width = F) 
```

